//! Crate for managing canister logs

#![forbid(unsafe_code)]
#![forbid(missing_docs)]

#[cfg(test)]
mod tests;

mod types;

pub use crate::types::{LogFilter, Sort};
use ic_canister_log::{export as export_logs, GlobalBuffer, Sink};
use serde::{Deserialize, Serialize};

/// Use this macro to declare en enum containing priority levels and the corresponding
/// buffers as defined in the [`ic_canister_log`]. The resulting log priority automatically
/// implements the [`LogPriority`] trait.
///
/// The [`GetLogFilter`] trait should be implemented manually for the resulting enum.
///
/// # Example
/// ```rust
/// use ic_canister_log::log;
/// use sol_rpc_logs::{declare_log_priorities, GetLogFilter, LogFilter};
///
/// // Each log priority is defined here with a capacity of 1000
/// declare_log_priorities! {
///     pub enum Priority {
///         Info(capacity = 1000, buffer = INFO),
///         Debug(capacity = 1000, buffer = DEBUG)
///     }
/// }
///
/// impl GetLogFilter for Priority {
///     fn get_log_filter() -> LogFilter {
///         LogFilter::ShowAll
///     }
/// }
///
/// log!(INFO, "Some noteworthy event");
/// log!(DEBUG, "A less noteworthy event");
/// ```
#[macro_export]
macro_rules! declare_log_priorities {
    (
        pub enum $enum_name:ident {
            $($variant:ident(capacity = $capacity:expr, buffer = $uppercase:expr)),*
        }
    ) => {
        // Declare the log priority enum
        #[derive(Copy, Clone, Debug, Eq, PartialEq, candid::CandidType, serde::Deserialize, serde::Serialize)]
        pub enum $enum_name {
            $($variant),*
        }

        // Declare the buffers for each log priority level
        $(paste::paste! {
            ic_canister_log::declare_log_buffer!(name = [<$uppercase _BUF>], capacity = $capacity);
            pub const $uppercase: $crate::PrintProxySink<$enum_name> = $crate::PrintProxySink(&$enum_name::$variant, &[<$uppercase _BUF>]);
        })*

        // Array containing all enum variants
        impl $enum_name {
            const VARIANTS: &'static [Self] = &[
                $(Self::$variant),*
            ];
        }

        // Implement some methods for the priority enum
        impl $crate::LogPriority for $enum_name {

            fn get_buffer(&self) -> &'static ic_canister_log::GlobalBuffer {
                match self {
                    $(Self::$variant => &paste::paste!([<$uppercase _BUF>]),)*
                }
            }

            fn as_str_uppercase(&self) -> &'static str {
                match self {
                    $(Self::$variant => stringify!($uppercase),)*
                }
            }

            fn get_priorities() -> &'static [Self] {
                Self::VARIANTS
            }
        }
    };
}

/// Represents a log priority level. This trait is meant to be implemented
/// automatically by the [`declare_log_priorities!`] macro.
pub trait LogPriority {
    /// Returns a reference to the [`GlobalBuffer`] where the log entries are stored.
    fn get_buffer(&self) -> &'static GlobalBuffer;

    /// Returns an uppercase `&str` representing a log priority level.
    fn as_str_uppercase(&self) -> &'static str;

    /// Returns an array containing all the log priority levels.
    fn get_priorities() -> &'static [Self]
    where
        Self: Sized;
}

/// Returns the [`LogFilter`] to check what entries to record. This trait should
/// be implemented manually for the log priority level enum generated by the
/// [`declare_log_priorities!`] macro.
pub trait GetLogFilter {
    /// Returns a [`LogFilter`]. Only log entries matching this filter will be recorded.
    fn get_log_filter() -> LogFilter;
}

/// Defines how log entries are displayed and appended to the corresponding [`GlobalBuffer`].
#[derive(Debug)]
pub struct PrintProxySink<Priority: 'static>(pub &'static Priority, pub &'static GlobalBuffer);

impl<Priority: LogPriority + GetLogFilter> Sink for PrintProxySink<Priority> {
    fn append(&self, entry: ic_canister_log::LogEntry) {
        let message = format!(
            "{} {}:{} {}",
            self.0.as_str_uppercase(),
            entry.file,
            entry.line,
            entry.message,
        );
        if Priority::get_log_filter().is_match(&message) {
            ic_cdk::println!("{}", message);
            self.1.append(entry)
        }
    }
}

/// A single log entry.
#[derive(Clone, Debug, Eq, PartialEq, Deserialize, serde::Serialize)]
pub struct LogEntry<Priority> {
    /// The time at which the log entry is recorded.
    pub timestamp: u64,
    /// The log entry priority level.
    pub priority: Priority,
    /// The source file in which this log entry was generated.
    pub file: String,
    /// The line in [`file`] in which this log entry was generated.
    pub line: u32,
    /// The log message.
    pub message: String,
    /// The index of this entry starting from the last canister upgrade.
    pub counter: u64,
}

/// A container for log entries at a given log priority level.
#[derive(Clone, Debug, Deserialize, serde::Serialize)]
pub struct Log<Priority> {
    /// The log entries for this priority level.
    pub entries: Vec<LogEntry<Priority>>,
}

impl<Priority> Default for Log<Priority> {
    fn default() -> Self {
        Self { entries: vec![] }
    }
}

impl<'de, Priority> Log<Priority>
where
    Priority: LogPriority + Clone + Copy + Deserialize<'de> + Serialize + 'static,
{
    /// Append all the entries from the given [`Priority`] to [`entries`].
    pub fn push_logs(&mut self, priority: Priority) {
        for entry in export_logs(priority.get_buffer()) {
            self.entries.push(LogEntry {
                timestamp: entry.timestamp,
                counter: entry.counter,
                priority,
                file: entry.file.to_string(),
                line: entry.line,
                message: entry.message,
            });
        }
    }

    /// Append all the entries from all priority levels to [`entries`].
    pub fn push_all(&mut self) {
        Priority::get_priorities()
            .iter()
            .for_each(|priority| self.push_logs(*priority));
    }

    /// Serialize the logs contained in `entries` into a JSON string.
    ///
    /// If the resulting string is larger than `max_body_size` bytes,
    /// truncate `entries` so the resulting serialized JSON string
    /// contains no more than `max_body_size` bytes.
    pub fn serialize_logs(&self, max_body_size: usize) -> String {
        let mut entries_json: String = serde_json::to_string(&self).unwrap_or_default();

        if entries_json.len() > max_body_size {
            let mut left = 0;
            let mut right = self.entries.len();

            while left < right {
                let mid = left + (right - left) / 2;
                let mut temp_log = self.clone();
                temp_log.entries.truncate(mid);
                let temp_entries_json = serde_json::to_string(&temp_log).unwrap_or_default();

                if temp_entries_json.len() <= max_body_size {
                    entries_json = temp_entries_json;
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
        }
        entries_json
    }

    /// Sort the log entries according `sort_order`.
    pub fn sort_logs(&mut self, sort_order: Sort) {
        match sort_order {
            Sort::Ascending => self.sort_asc(),
            Sort::Descending => self.sort_desc(),
        }
    }

    fn sort_asc(&mut self) {
        self.entries.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
    }

    fn sort_desc(&mut self) {
        self.entries.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
    }
}
